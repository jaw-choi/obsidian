---
title: 1교시
---

# 1교시 요약

함수 포인터로 시작한 콜백 개념이 함수 객체(펑터)와 std::function, 람다로 확장되면서 더 안전하고 유연한 형태로 발전했고, STL 알고리즘에서 그 진가가 드러남.

## 콜백과 시스템 프로그래밍
1. 운영체제 API나 그래픽스, 윈도우 시스템 프로그래밍에서는 “내가 만든 함수를 시스템에 등록해두고, 시스템이 나중에 거꾸로 호출하는” 패턴이 매우 많음.
2. C#에서는 이를 delegate로 부르지만, C++에서는 함수 포인터/함수 객체/람다 등으로 같은 목적(로직 전달)을 달성함.

## 함수 포인터 핵심
- 함수의 주소를 변수에 담아 “로직 자체를 인자로 넘기는” 수단.
- 실무에서는 typedef 또는 using으로 “함수 포인터 타입 별칭”을 만들어 깔끔하게 쓰는 방식이 흔함.

## std::function의 위치
- 함수 포인터처럼 “호출 가능한 대상”을 담는 래퍼(함수 래퍼/타입 소거 개념).
- 실무에서 편의성 때문에 자주 쓰지만, 성능/할당/인라이닝 관점은 따로 고려 포인트가 됨.

## 람다
- “함수 선언 + 구현”을 호출 지점에 바로 적어서 로직 전달 단계를 줄임.
- STL 알고리즘(정렬, 검색, 삭제 조건 등)에 특히 잘 어울림.
- [] 캡처를 통해 상태를 들고 다닐 수 있어 매우 편리함.
